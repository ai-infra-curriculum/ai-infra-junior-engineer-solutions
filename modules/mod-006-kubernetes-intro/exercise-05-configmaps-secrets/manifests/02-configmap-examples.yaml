---
# Example 1: ConfigMap with literal values
# Simple key-value pairs for application configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config-literals
  namespace: config-demo
  labels:
    app: demo-app
    type: configuration
data:
  # Simple key-value pairs
  APP_NAME: "My Application"
  APP_VERSION: "1.0.0"
  LOG_LEVEL: "info"
  DATABASE_HOST: "postgres.database.svc.cluster.local"
  DATABASE_PORT: "5432"
  FEATURE_FLAG_NEW_UI: "true"
  MAX_CONNECTIONS: "100"

---
# Example 2: ConfigMap with file-like content
# Configuration files stored as ConfigMap data
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config-files
  namespace: config-demo
  labels:
    app: demo-app
    type: configuration-files
data:
  # Application properties file
  application.properties: |
    # Application Configuration
    server.port=8080
    server.host=0.0.0.0

    # Database Configuration
    database.url=jdbc:postgresql://postgres:5432/mydb
    database.username=appuser
    database.pool.size=20
    database.pool.maxWait=30000

    # Logging Configuration
    logging.level=INFO
    logging.format=json
    logging.destination=stdout

    # Feature Flags
    features.beta.enabled=true
    features.experimental.enabled=false

  # Nginx configuration
  nginx.conf: |
    worker_processes auto;
    error_log /var/log/nginx/error.log warn;
    pid /var/run/nginx.pid;

    events {
        worker_connections 1024;
    }

    http {
        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';

        access_log /var/log/nginx/access.log main;

        sendfile on;
        tcp_nopush on;
        keepalive_timeout 65;
        gzip on;

        server {
            listen 80;
            server_name localhost;

            location / {
                root /usr/share/nginx/html;
                index index.html index.htm;
            }

            location /health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
        }
    }

  # JSON configuration
  config.json: |
    {
      "application": {
        "name": "demo-app",
        "version": "1.0.0",
        "environment": "production"
      },
      "database": {
        "host": "postgres.database.svc.cluster.local",
        "port": 5432,
        "name": "mydb",
        "ssl": true,
        "pool": {
          "min": 5,
          "max": 20
        }
      },
      "cache": {
        "enabled": true,
        "type": "redis",
        "host": "redis.cache.svc.cluster.local",
        "port": 6379,
        "ttl": 3600
      },
      "logging": {
        "level": "info",
        "format": "json",
        "outputs": ["stdout", "file"]
      }
    }

  # YAML configuration
  config.yaml: |
    application:
      name: demo-app
      version: 1.0.0
      environment: production

    server:
      host: 0.0.0.0
      port: 8080
      timeout: 30

    database:
      host: postgres.database.svc.cluster.local
      port: 5432
      name: mydb
      ssl: true
      pool:
        min: 5
        max: 20

    features:
      beta_ui: true
      experimental_features: false
      dark_mode: true

---
# Example 3: ConfigMap with binary data
# For non-UTF8 data, use binaryData instead of data
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config-binary
  namespace: config-demo
  labels:
    app: demo-app
    type: binary-config
binaryData:
  # Base64 encoded binary data
  # This would typically be generated, not hand-written
  logo.png: iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==

---
# Example 4: ConfigMap for environment-specific configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config-dev
  namespace: config-demo
  labels:
    app: demo-app
    environment: development
data:
  ENV: "development"
  DEBUG: "true"
  LOG_LEVEL: "debug"
  DATABASE_HOST: "postgres-dev.database.svc.cluster.local"
  CACHE_ENABLED: "false"
  FEATURE_FLAGS: "all_enabled"

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config-prod
  namespace: config-demo
  labels:
    app: demo-app
    environment: production
data:
  ENV: "production"
  DEBUG: "false"
  LOG_LEVEL: "warn"
  DATABASE_HOST: "postgres-prod.database.svc.cluster.local"
  CACHE_ENABLED: "true"
  FEATURE_FLAGS: "stable_only"

---
# Example 5: ConfigMap for scripts
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-scripts
  namespace: config-demo
  labels:
    app: demo-app
    type: scripts
data:
  init.sh: |
    #!/bin/bash
    set -e

    echo "Initializing application..."

    # Wait for database to be ready
    echo "Waiting for database..."
    until pg_isready -h $DATABASE_HOST -p $DATABASE_PORT -U $DATABASE_USER; do
      echo "Database is unavailable - sleeping"
      sleep 2
    done

    echo "Database is ready!"

    # Run database migrations
    echo "Running database migrations..."
    python manage.py migrate --no-input

    # Create default admin user if not exists
    echo "Creating default admin user..."
    python manage.py ensure_adminuser --no-input

    echo "Initialization complete!"

  backup.sh: |
    #!/bin/bash
    set -e

    BACKUP_DIR="/backups"
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILE="$BACKUP_DIR/backup_$TIMESTAMP.sql"

    echo "Starting database backup..."
    echo "Backup file: $BACKUP_FILE"

    pg_dump -h $DATABASE_HOST \
            -p $DATABASE_PORT \
            -U $DATABASE_USER \
            -d $DATABASE_NAME \
            -F c \
            -f $BACKUP_FILE

    echo "Backup completed successfully!"
    echo "File size: $(du -h $BACKUP_FILE | cut -f1)"

  healthcheck.sh: |
    #!/bin/bash

    # Check if application is responding
    response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)

    if [ $response -eq 200 ]; then
      echo "Application is healthy"
      exit 0
    else
      echo "Application is unhealthy (HTTP $response)"
      exit 1
    fi

---
# Commands to create ConfigMaps imperatively (for reference):
#
# From literal values:
# kubectl create configmap app-config \
#   --from-literal=APP_NAME="My App" \
#   --from-literal=LOG_LEVEL="info" \
#   -n config-demo
#
# From file:
# kubectl create configmap app-config \
#   --from-file=application.properties \
#   -n config-demo
#
# From directory:
# kubectl create configmap app-config \
#   --from-file=./config/ \
#   -n config-demo
#
# From env file:
# kubectl create configmap app-config \
#   --from-env-file=.env \
#   -n config-demo
