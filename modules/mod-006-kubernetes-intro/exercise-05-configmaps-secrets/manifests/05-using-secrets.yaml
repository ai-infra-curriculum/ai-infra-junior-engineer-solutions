---
# Example 1: Using Secret as environment variables
# Individual keys from Secret as env vars
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-env
  namespace: config-demo
  labels:
    app: demo-app
    example: secret-env
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== Environment Variables from Secret ==="
        echo "Database Username: $DB_USER"
        echo "Database Password: $DB_PASS"
        echo "API Key: $API_KEY"
        echo "JWT Secret: $JWT_SECRET"
        echo ""
        echo "Sleeping... (use 'kubectl logs' to see output)"
        sleep 3600
    env:
    # Individual keys from Secret
    - name: DB_USER
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: database-username
    - name: DB_PASS
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: database-password
    - name: API_KEY
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: api-key
    - name: JWT_SECRET
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: jwt-secret
  restartPolicy: Never

---
# Example 2: Using envFrom to import all Secret keys as environment variables
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-envfrom
  namespace: config-demo
  labels:
    app: demo-app
    example: secret-envfrom
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== All Secret Keys as Environment Variables ==="
        # Don't print actual values in production!
        echo "database-username: $database_username"
        echo "database-password: [REDACTED]"
        echo "api-key: [REDACTED]"
        echo ""
        echo "Note: All keys from 'app-secrets' are available as env vars"
        sleep 3600
    envFrom:
    # Import all keys from Secret as environment variables
    - secretRef:
        name: app-secrets
  restartPolicy: Never

---
# Example 3: Using Secret as volume mount
# Mount Secret data as files in the container
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-volume
  namespace: config-demo
  labels:
    app: demo-app
    example: secret-volume
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== Secret Files ==="
        ls -la /etc/secrets/
        echo ""
        echo "=== Reading Secrets from Files ==="
        echo "Database Username: $(cat /etc/secrets/database-username)"
        echo "Database Password: $(cat /etc/secrets/database-password)"
        echo "API Key: $(cat /etc/secrets/api-key)"
        echo ""
        echo "Each Secret key becomes a separate file"
        sleep 3600
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secrets
      readOnly: true  # Always use readOnly for secrets
  volumes:
  - name: secret-volume
    secret:
      secretName: app-secrets

---
# Example 4: Mounting specific keys from Secret
# Only mount selected keys instead of all data
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-selective
  namespace: config-demo
  labels:
    app: demo-app
    example: secret-selective
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== Selectively Mounted Secrets ==="
        ls -la /etc/secrets/
        echo ""
        echo "Only database credentials were mounted"
        echo "Username: $(cat /etc/secrets/db-user)"
        echo "Password: $(cat /etc/secrets/db-pass)"
        sleep 3600
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secrets
      readOnly: true
  volumes:
  - name: secret-volume
    secret:
      secretName: app-secrets
      items:
      # Only mount specific keys with custom filenames
      - key: database-username
        path: db-user
      - key: database-password
        path: db-pass

---
# Example 5: Secret with custom file permissions
# Set specific permissions on mounted secret files
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-permissions
  namespace: config-demo
  labels:
    app: demo-app
    example: secret-permissions
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== Secret File Permissions ==="
        ls -la /etc/secrets/
        echo ""
        echo "Notice the permissions: -r--------"
        echo "Only the owner (container user) can read"
        sleep 3600
    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secrets
      readOnly: true
  volumes:
  - name: secret-volume
    secret:
      secretName: app-secrets
      defaultMode: 0400  # r-------- (owner read-only)

---
# Example 6: Using imagePullSecrets for private registries
# Automatically uses Docker registry secret for pulling images
apiVersion: v1
kind: Pod
metadata:
  name: pod-private-image
  namespace: config-demo
  labels:
    app: demo-app
    example: image-pull-secrets
spec:
  containers:
  - name: app
    # This would be a private image
    image: busybox:1.36
    command: ["sleep", "3600"]
  # Reference to Docker registry secret
  imagePullSecrets:
  - name: docker-registry-secret

---
# Example 7: TLS Secret usage with Nginx
# Mount TLS certificate and key for HTTPS
apiVersion: v1
kind: Pod
metadata:
  name: pod-tls-secret
  namespace: config-demo
  labels:
    app: demo-app
    example: tls-secret
spec:
  containers:
  - name: nginx
    image: nginx:1.25-alpine
    ports:
    - containerPort: 443
      name: https
    volumeMounts:
    # Mount TLS certificate and key
    - name: tls-certs
      mountPath: /etc/nginx/ssl
      readOnly: true
    # Mount custom nginx config that uses the certs
    - name: nginx-config
      mountPath: /etc/nginx/nginx.conf
      subPath: nginx.conf
      readOnly: true
  volumes:
  - name: tls-certs
    secret:
      secretName: tls-secret
      items:
      - key: tls.crt
        path: server.crt
      - key: tls.key
        path: server.key
      defaultMode: 0400
  - name: nginx-config
    configMap:
      name: app-config-files
      items:
      - key: nginx.conf
        path: nginx.conf

---
# Example 8: SSH key Secret usage
# Mount SSH private key for Git operations
apiVersion: v1
kind: Pod
metadata:
  name: pod-ssh-secret
  namespace: config-demo
  labels:
    app: demo-app
    example: ssh-secret
spec:
  containers:
  - name: git-sync
    image: alpine/git:latest
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== SSH Key Setup ==="
        mkdir -p ~/.ssh
        cp /etc/ssh-keys/ssh-privatekey ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ls -la ~/.ssh/
        echo ""
        echo "SSH key is ready for Git operations"
        echo "In production, this would clone a private repository"
        sleep 3600
    volumeMounts:
    - name: ssh-key
      mountPath: /etc/ssh-keys
      readOnly: true
  volumes:
  - name: ssh-key
    secret:
      secretName: ssh-auth-secret
      defaultMode: 0400

---
# Example 9: Basic Auth Secret usage
# HTTP basic authentication credentials
apiVersion: v1
kind: Pod
metadata:
  name: pod-basic-auth
  namespace: config-demo
  labels:
    app: demo-app
    example: basic-auth
spec:
  containers:
  - name: app
    image: curlimages/curl:latest
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== Basic Auth Credentials ==="
        USERNAME=$(cat /etc/auth/username)
        PASSWORD=$(cat /etc/auth/password)
        echo "Username: $USERNAME"
        echo "Password: [REDACTED]"
        echo ""
        echo "Making authenticated request..."
        # Example: curl -u "$USERNAME:$PASSWORD" https://api.example.com
        echo "In production, use these credentials for API calls"
        sleep 3600
    volumeMounts:
    - name: auth
      mountPath: /etc/auth
      readOnly: true
  volumes:
  - name: auth
    secret:
      secretName: basic-auth-secret

---
# Example 10: Multiple Secrets in one Pod
# Using different secrets for different purposes
apiVersion: v1
kind: Pod
metadata:
  name: pod-multiple-secrets
  namespace: config-demo
  labels:
    app: demo-app
    example: multiple-secrets
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== Environment Variables (from app-secrets) ==="
        echo "API Key: $API_KEY"
        echo ""
        echo "=== Database Credentials (from volume) ==="
        cat /etc/db-secrets/database-username
        echo ""
        echo "=== External Service Credentials (from volume) ==="
        ls -la /etc/external-secrets/
        echo ""
        sleep 3600
    env:
    # API key as environment variable
    - name: API_KEY
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: api-key
    volumeMounts:
    # Database credentials as files
    - name: db-secrets
      mountPath: /etc/db-secrets
      readOnly: true
    # External service credentials as files
    - name: external-secrets
      mountPath: /etc/external-secrets
      readOnly: true
  volumes:
  - name: db-secrets
    secret:
      secretName: app-secrets
      items:
      - key: database-username
        path: database-username
      - key: database-password
        path: database-password
  - name: external-secrets
    secret:
      secretName: external-services

---
# Example 11: Secret with optional flag
# Pod will start even if the Secret doesn't exist
apiVersion: v1
kind: Pod
metadata:
  name: pod-secret-optional
  namespace: config-demo
  labels:
    app: demo-app
    example: secret-optional
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "Pod started successfully"
        echo "Optional Secret may or may not be present"
        if [ -d /etc/optional-secrets ]; then
          echo "Optional secrets are present"
        else
          echo "Optional secrets are not present"
        fi
        sleep 3600
    env:
    # Optional environment variable
    - name: OPTIONAL_SECRET
      valueFrom:
        secretKeyRef:
          name: nonexistent-secret
          key: some-key
          optional: true  # Pod will start even if Secret doesn't exist
    volumeMounts:
    # Optional volume mount
    - name: optional-secrets
      mountPath: /etc/optional-secrets
      readOnly: true
  volumes:
  - name: optional-secrets
    secret:
      secretName: nonexistent-secret
      optional: true  # Pod will start even if Secret doesn't exist

---
# Example 12: Deployment with ConfigMaps and Secrets
# Real-world application using both configuration and secrets
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secure-app
  namespace: config-demo
  labels:
    app: secure-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: secure-app
  template:
    metadata:
      labels:
        app: secure-app
    spec:
      containers:
      - name: app
        image: busybox:1.36
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "=== Secure Application Starting ==="
            echo "App Name: $APP_NAME"
            echo "Environment: $ENV"
            echo "Log Level: $LOG_LEVEL"
            echo ""
            echo "=== Connecting to Database ==="
            DB_USER=$(cat /etc/secrets/database-username)
            DB_PASS=$(cat /etc/secrets/database-password)
            echo "User: $DB_USER"
            echo "Password: [REDACTED]"
            echo "Host: $DATABASE_HOST"
            echo ""
            echo "=== External Services ==="
            AWS_KEY=$(cat /etc/external/aws-access-key-id)
            echo "AWS Access Key: ${AWS_KEY:0:10}..."
            echo ""
            echo "Application running securely..."

            # Simulate application
            while true; do
              echo "[$(date)] Processing with user $DB_USER"
              sleep 30
            done
        # Public configuration from ConfigMap
        envFrom:
        - configMapRef:
            name: app-config-literals
        - configMapRef:
            name: app-config-dev
        # Individual secret as environment variable
        env:
        - name: API_SECRET
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: api-secret
        volumeMounts:
        # Database credentials from Secret
        - name: db-secrets
          mountPath: /etc/secrets
          readOnly: true
        # External service credentials from Secret
        - name: external-secrets
          mountPath: /etc/external
          readOnly: true
        # Application config files from ConfigMap
        - name: config-files
          mountPath: /etc/config
          readOnly: true
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        # Security best practices
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
      volumes:
      - name: db-secrets
        secret:
          secretName: app-secrets
          items:
          - key: database-username
            path: database-username
          - key: database-password
            path: database-password
          defaultMode: 0400
      - name: external-secrets
        secret:
          secretName: external-services
          defaultMode: 0400
      - name: config-files
        configMap:
          name: app-config-files
      # Use private registry secret
      imagePullSecrets:
      - name: docker-registry-secret

---
# Example 13: Projected volume combining ConfigMaps and Secrets
# Mount multiple ConfigMaps and Secrets into a single directory
apiVersion: v1
kind: Pod
metadata:
  name: pod-projected-volume
  namespace: config-demo
  labels:
    app: demo-app
    example: projected-volume
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["/bin/sh", "-c"]
    args:
      - |
        echo "=== Projected Volume Contents ==="
        ls -la /etc/combined/
        echo ""
        echo "This directory contains both ConfigMap and Secret data"
        echo ""
        echo "=== Public Config ==="
        cat /etc/combined/app-name
        echo ""
        echo "=== Secret Data ==="
        cat /etc/combined/api-key
        echo ""
        sleep 3600
    volumeMounts:
    - name: combined
      mountPath: /etc/combined
      readOnly: true
  volumes:
  - name: combined
    projected:
      sources:
      # Include specific keys from ConfigMap
      - configMap:
          name: app-config-literals
          items:
          - key: APP_NAME
            path: app-name
          - key: LOG_LEVEL
            path: log-level
      # Include specific keys from Secret
      - secret:
          name: app-secrets
          items:
          - key: api-key
            path: api-key
          - key: jwt-secret
            path: jwt-secret
      defaultMode: 0400

---
# SECURITY BEST PRACTICES:
#
# 1. Always use readOnly: true for Secret mounts
# 2. Use restrictive file permissions (0400 or 0600)
# 3. Prefer volume mounts over environment variables for secrets
#    - Env vars can leak in logs, crash dumps, child processes
#    - Files are easier to protect with permissions
# 4. Use securityContext to run as non-root user
# 5. Enable readOnlyRootFilesystem when possible
# 6. Use imagePullSecrets for private registries
# 7. Never log secret values
# 8. Use optional: true only when appropriate
# 9. Rotate secrets regularly
# 10. Use external secret managers in production:
#     - HashiCorp Vault
#     - AWS Secrets Manager
#     - Azure Key Vault
#     - Google Secret Manager
#     - Sealed Secrets
#     - External Secrets Operator
#
# Commands to interact with these examples:
#
# Deploy all examples:
# kubectl apply -f 05-using-secrets.yaml
#
# View environment variables (BE CAREFUL - secrets visible):
# kubectl exec -n config-demo pod-secret-env -- env
#
# View mounted secret files:
# kubectl exec -n config-demo pod-secret-volume -- ls -la /etc/secrets/
# kubectl exec -n config-demo pod-secret-volume -- cat /etc/secrets/database-username
#
# View logs:
# kubectl logs -n config-demo pod-secret-env
#
# Get secret data (base64 encoded):
# kubectl get secret app-secrets -n config-demo -o yaml
#
# Decode secret:
# kubectl get secret app-secrets -n config-demo -o jsonpath='{.data.database-password}' | base64 -d
#
# Watch deployment:
# kubectl get pods -n config-demo -l app=secure-app -w
#
# Cleanup:
# kubectl delete -f 05-using-secrets.yaml
